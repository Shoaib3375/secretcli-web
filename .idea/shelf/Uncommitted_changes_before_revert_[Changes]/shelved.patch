Index: internal/app/secret/handler.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package secret\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"github.com/go-chi/chi\"\r\n\t\"net/http\"\r\n\t\"strconv\"\r\n\t\"time\"\r\n\r\n\t\"github.com/mahinops/secretcli-web/internal/utils/auth\"\r\n\t\"github.com/mahinops/secretcli-web/internal/utils/common\"\r\n\t\"github.com/mahinops/secretcli-web/internal/utils/crypto\"\r\n\t\"github.com/mahinops/secretcli-web/model\"\r\n)\r\n\r\ntype SecretHandler struct {\r\n\tservice      *SecretService\r\n\tcommonConfig *common.CommonConfig\r\n}\r\n\r\n// NewSecretHandler creates a new instance of SecretHandler// NewSecretHandler creates a new instance of SecretHandler\r\nfunc NewSecretHandler(service *SecretService, commonConfig *common.CommonConfig) *SecretHandler {\r\n\treturn &SecretHandler{service: service, commonConfig: commonConfig} // Update this line\r\n}\r\n\r\nfunc (h *SecretHandler) handleError(w http.ResponseWriter, code int, err error) {\r\n\tw.WriteHeader(code)\r\n\tjson.NewEncoder(w).Encode(model.ErrorResponse{\r\n\t\tCode:    code,\r\n\t\tMessage: err.Error(),\r\n\t})\r\n}\r\n\r\n// GeneratePassword handles the generation of a password\r\n//\r\n//\t@Summary\t\tGenerate a secure password\r\n//\t@Description\tGenerates a password based on provided parameters.\r\n//\t@Tags\t\t\tsecrets\r\n//\t@Accept\t\t\tjson\r\n//\t@Produce\t\tjson\r\n//\t@Param\t\t\tAuthorization\theader\t\tstring\t\t\t\t\t\t\t\t\ttrue\t\"Bearer <token>\"\r\n//\t@Param\t\t\tbody\t\t\tbody\t\tmodel.SwaggerGeneratePasswordRequest\ttrue\t\"Password generation parameters\"\r\n//\t@Success\t\t200\t\t\t\t{object}\tmodel.SuccessResponse\r\n//\t@Failure\t\t400\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t401\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t500\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Router\t\t\t/secret/api/generatepassword [post]\r\nfunc (h *SecretHandler) GeneratePassword(w http.ResponseWriter, r *http.Request) {\r\n\t// Authorization check\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tvar passwordReq model.GeneratePasswordRequest\r\n\tif err := common.ParseAndValidatePayload(r, &passwordReq); err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tpasswordGenerated, err := h.service.GeneratePassword(r.Context(), passwordReq.Length, passwordReq.IncludeSpecialSymbol)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tcommon.RespondWithSuccess(w, http.StatusOK, \"Password generated successfully\", map[string]interface{}{\r\n\t\t\"password\": passwordGenerated,\r\n\t})\r\n}\r\n\r\n// Create handles the creation of a new secret.\r\n//\r\n//\t@Summary\t\tCreate a new secret\r\n//\t@Description\tThis endpoint allows users to create a new secret with an encrypted password.\r\n//\t@Tags\t\t\tsecrets\r\n//\t@Accept\t\t\tjson\r\n//\t@Produce\t\tjson\r\n//\t@Param\t\t\tAuthorization\theader\t\tstring\t\t\t\t\t\ttrue\t\"Bearer token for authentication\"\r\n//\t@Param\t\t\tsecret\t\t\tbody\t\tmodel.SwaggerSecretRequest\ttrue\t\"Secret payload containing title, username, password, note, email, website, and user ID\"\r\n//\t@Success\t\t201\t\t\t\t{object}\tmodel.SuccessResponse\r\n//\t@Failure\t\t400\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t401\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t500\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Router\t\t\t/secret/api/create [post]\r\nfunc (h *SecretHandler) Create(w http.ResponseWriter, r *http.Request) {\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tvar secret model.Secret\r\n\tif err := common.ParseAndValidatePayload(r, &secret); err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tsecret.UserID = user.ID\r\n\tif secret.Title == \"\" || secret.Password == \"\" {\r\n\t\th.handleError(w, http.StatusBadRequest, errors.New(\"title and password cannot be empty\"))\r\n\t\treturn\r\n\t}\r\n\r\n\tsecret.Password, err = crypto.Encrypt(secret.Password, []byte(h.commonConfig.SecretEncKey))\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tsecret.CreatedAt = time.Now()\r\n\tsecret.UpdatedAt = &secret.CreatedAt\r\n\tif err := h.service.Create(r.Context(), secret); err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tcommon.RespondWithSuccess(w, http.StatusCreated, \"Secret created successfully\", map[string]interface{}{})\r\n}\r\n\r\n// List handles the retrieval of user secrets.\r\n//\r\n//\t@Summary\t\tList user secrets\r\n//\t@Description\tThis endpoint retrieves all secrets associated with the authenticated user.\r\n//\t@Tags\t\t\tsecrets\r\n//\t@Accept\t\t\tjson\r\n//\t@Produce\t\tjson\r\n//\t@Param\t\t\tAuthorization\theader\t\tstring\ttrue\t\"Bearer <token>\"\r\n//\t@Success\t\t200\t\t\t\t{object}\tmodel.SuccessResponse\r\n//\t@Failure\t\t401\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t500\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Router\t\t\t/secret/api/list [get]\r\nfunc (h *SecretHandler) List(w http.ResponseWriter, r *http.Request) {\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tsecrets, err := h.service.List(r.Context(), user.ID)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tfor i := range secrets {\r\n\t\tif secrets[i].Password == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif !crypto.IsValidBase64(secrets[i].Password) {\r\n\t\t\tsecrets[i].Password = \"[CORRUPTED]\"\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif decrypted, err := crypto.Decrypt(secrets[i].Password, []byte(h.commonConfig.SecretEncKey)); err == nil {\r\n\t\t\tsecrets[i].Password = decrypted\r\n\t\t} else {\r\n\t\t\tsecrets[i].Password = \"[CORRUPTED]\"\r\n\t\t}\r\n\t}\r\n\r\n\tcommon.RespondWithSuccess(w, http.StatusOK, \"Secrets retrieved successfully\", map[string]interface{}{\r\n\t\t\"secrets\": secrets,\r\n\t})\r\n}\r\n\r\n// SecretDetail retrieves the details of a specific secret.\r\n//\r\n//\t@Summary\t\tGet Secret Details\r\n//\t@Description\tRetrieves details of a specific secret associated with the authenticated user.\r\n//\t@Tags\t\t\tsecrets\r\n//\t@Accept\t\t\tjson\r\n//\t@Produce\t\tjson\r\n//\t@Param\t\t\tAuthorization\theader\t\tstring\t\t\t\t\t\t\t\ttrue\t\"Bearer <token>\"\r\n//\t@Param\t\t\tsecret_id\t\tbody\t\tmodel.SwaggerSecretDetailRequest\ttrue\t\"ID of the secret to retrieve\"\r\n//\t@Success\t\t200\t\t\t\t{object}\tmodel.SuccessResponse\r\n//\t@Failure\t\t400\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t401\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Failure\t\t500\t\t\t\t{object}\tmodel.ErrorResponse\r\n//\t@Router\t\t\t/secret/api/secretdetail [post]\r\nfunc (h *SecretHandler) SecretDetail(w http.ResponseWriter, r *http.Request) {\r\n\t// Authorization check\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tvar secretDetail model.SecretDetail\r\n\tif err := common.ParseAndValidatePayload(r, &secretDetail); err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tsecret, err := h.service.SecretDetail(r.Context(), user.ID, secretDetail.SecretID)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tcommon.RespondWithSuccess(w, http.StatusOK, \"Secrets detail retrieved successfully\", map[string]interface{}{\r\n\t\t\"secret\": secret,\r\n\t})\r\n}\r\n\r\nfunc (h *SecretHandler) Delete(w http.ResponseWriter, r *http.Request) {\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tidStr := chi.URLParam(r, \"id\")\r\n\tsecretID, err := strconv.Atoi(idStr)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, err)\r\n\t\treturn\r\n\t}\r\n\r\n\terr = h.service.DeleteSecretByID(r.Context(), user.ID, secretID)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\tw.WriteHeader(http.StatusNoContent)\r\n}\r\n\r\nfunc (h *SecretHandler) Update(w http.ResponseWriter, r *http.Request) {\r\n\t// Auth\r\n\tuser, err := auth.ValidateToken(r, h.commonConfig.JWTSecretKey)\r\n\tif err != nil || user == nil {\r\n\t\th.handleError(w, http.StatusUnauthorized, err)\r\n\t\treturn\r\n\t}\r\n\r\n\t// Parse ID\r\n\tidStr := chi.URLParam(r, \"id\")\r\n\tid, err := strconv.Atoi(idStr)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, fmt.Errorf(\"invalid secret ID\"))\r\n\t\treturn\r\n\t}\r\n\r\n\tvar input model.Secret\r\n\tif err := json.NewDecoder(r.Body).Decode(&input); err != nil {\r\n\t\th.handleError(w, http.StatusBadRequest, fmt.Errorf(\"invalid JSON payload\"))\r\n\t\treturn\r\n\t}\r\n\r\n\terr = h.service.UpdateSecret(r.Context(), user.ID, id, input)\r\n\tif err != nil {\r\n\t\th.handleError(w, http.StatusInternalServerError, err)\r\n\t\treturn\r\n\t}\r\n\r\n\tcommon.RespondWithSuccess(w, http.StatusOK, \"Secret updated successfully\", map[string]interface{}{\r\n\t\t\"secret\": input,\r\n\t})\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/app/secret/handler.go b/internal/app/secret/handler.go
--- a/internal/app/secret/handler.go	(revision 1b425ff36287a003b3d3b95b15bfc7cff93f7cd3)
+++ b/internal/app/secret/handler.go	(date 1758311161689)
@@ -249,6 +249,14 @@
 		return
 	}
 
+	if input.Password != "" {
+		input.Password, err = crypto.Encrypt(input.Password, []byte(h.commonConfig.SecretEncKey))
+		if err != nil {
+			h.handleError(w, http.StatusInternalServerError, err)
+			return
+		}
+	}
+
 	err = h.service.UpdateSecret(r.Context(), user.ID, id, input)
 	if err != nil {
 		h.handleError(w, http.StatusInternalServerError, err)
